; Copyright (c) Microsoft Corporation.
; Licensed under the MIT License.

; The __quantum__qis__* definitions should be automatically generated by QIR, depending on the specific target.
; However, for simulator targets we provide an optional simple bridge that covers commonly used intrinsics. 

;=======================================================================================================================
; QIR types
;
%Array = type opaque
%Result = type opaque
%String = type opaque

;===============================================================================
; quantum.qis math functions declarations
;

; LLVM intrinsics (https://llvm.org/docs/LangRef.html):
; TODO: consider calling these directly from the compiler-generated .ll code, rather than through the QIR. #632
declare double      @llvm.sqrt.f64(double %.val)
declare double      @llvm.log.f64(double %Val)
declare double      @llvm.sin.f64(double %Val)
declare double      @llvm.cos.f64(double %Val)

;===============================================================================
; quantum.qis math functions implementation
;
; API for the user code:
define dllexport double @__quantum__qis__nan__body() {                ; Q#: function NAN() : Double       http://www.cplusplus.com/reference/cmath/nan-function/
  %result = call double @llvm.sqrt.f64(double -1.0)         ; sqrt(<negative>) -> NaN   
  ret double %result
}

define dllexport double @__quantum__qis__sqrt__body(double %d) {      ; https://en.cppreference.com/w/cpp/numeric/math/sqrt
  %result = call double @llvm.sqrt.f64(double %d)           
  ret double %result
}

define dllexport double @__quantum__qis__log__body(double %d) {       ; https://en.cppreference.com/w/cpp/numeric/math/log
  %result = call double @llvm.log.f64(double %d)           
  ret double %result
}

define dllexport i1 @__quantum__qis__isnegativeinfinity__body(double %d) {    ; Q#: function IsNegativeInfinity(d : Double) : Bool
                                                                    ; https://en.cppreference.com/w/cpp/numeric/math/log    https://llvm.org/docs/LangRef.html#llvm-log-intrinsic
  %negInf = call double @llvm.log.f64(double 0.0)                   ; ln(0) -> (-infinity)
  %result = fcmp oeq double %negInf, %d                             ; %result = (%negInf == %d)
  ret i1 %result
}

; function Sin (theta : Double) : Double
; https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.math.sin
define dllexport double @__quantum__qis__sin__body(double %theta) {       ; https://en.cppreference.com/w/cpp/numeric/math/sin
    %result = call double @llvm.sin.f64(double %theta)          ; https://llvm.org/docs/LangRef.html#llvm-sin-intrinsic
    ret double %result
}

; function Cos (theta : Double) : Double
; https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.math.cos
define dllexport double @__quantum__qis__cos__body(double %theta) {       ; https://en.cppreference.com/w/cpp/numeric/math/cos
    %result = call double @llvm.cos.f64(double %theta)          ; https://llvm.org/docs/LangRef.html#llvm-cos-intrinsic
    ret double %result
}

; function Tan (theta : Double) : Double
; https://docs.microsoft.com/qsharp/api/qsharp/microsoft.quantum.math.tan
define dllexport double @__quantum__qis__tan__body(double %theta) {       ; https://en.cppreference.com/w/cpp/numeric/math/tan
    %sin = call double @llvm.sin.f64(double %theta)
    %cos = call double @llvm.cos.f64(double %theta)
    %result = fdiv double %sin, %cos                            ; tg(x) = sin(x) / cos(x)
    ret double %result
}

;===============================================================================
; quantum.qis AssertMeasurementProbability functions/operations implementation
;
define dllexport void @__quantum__qis__assertmeasurementprobability__adj(
  %Array* %.bases, %Array* %.qubits, %Result* %.result, double %prob, %String* %.msg, double %tol) {
  ; Empty.
  ret void
}

define dllexport void @__quantum__qis__assertmeasurementprobability__ctl(
  %Array* %.ctrlQubits,
  %Array* %.bases, %Array* %.qubits, %Result* %.result, double %prob, %String* %.msg, double %tol) {
  ; Empty.
  ret void
}

define dllexport void @__quantum__qis__assertmeasurementprobability__ctladj(
  %Array* %.ctrlQubits,
  %Array* %.bases, %Array* %.qubits, %Result* %.result, double %prob, %String* %.msg, double %tol) {
  ; Empty.
  ret void
}
